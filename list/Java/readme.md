# List
List의 구현은 Array(배열) 기반, 연결(Link) 기반의 리스트가 있다. 배열 리스트의 배열이 내부적으로 실제 데이터를 저장하는 역할을 하기 떄문에 아래와 같은 특징을 갖는다. 

- 배열의 인덱스(index)를 통한 조회가 쉽다.
- 배열은 생성 시 메모리 구조가 고정되기 때문에 마지막 인덱스가 아닌 곳의 데이터 삽입, 삭제 시 새로운 배열 생성 및 복사 작업이 동반된다.
- 위와 똑같은 이유로 배열 생성 시 적절한 크기의 배열을 생성하지 않았을 경우, 데이터 삽입 시 전제 배열에 대한 복사가 동반될 수도 있다.

연결 리스트의 경우에는 각 node가 데이터를 저장하며 다음 node는 이전 node가 가리키는 방식으로 구현되며 아래와 같은 특징을 갖는다.

- 인덱스가 아닌 node를 가리키는 포인터를 통해 조회가 이루어지기 때문에 특정 데이터를 조회하기 위해 첫 node부터 순차적으로 조회가 이루어져야한다.
- 각 node는 다음 node를 가리키기 위해 포인터를 이용하기 때문에 데이터 삽입 및 삭제가 용이하다. 물론 해당 위치까지 반복적인 조회가 불가피하다.

각 리스트 구현에 대해 데이터 개수(n)에 따른 연산 시간 복잡도는 아래와 같다.

|               | add(0) | add(n-1) | remove(0) | remove(n) |
|---------------|--------|----------|-----------|-----------|
| 배열리스트         | O(1)   | O(1)     | O(1)      | O(1)      |
| 연결리스트(원형,양방향) | O(1)   | O(n)     | O(1)      | O(n)      |

jdk8 기준, java 내 List 자료구조 구현은 java.util 패키지의 ArraysList, LinkedList 클래스가 있다.
LinkedList 클래스의 경우 첫 node와 마지막 node를 가리키는 각각의 head, tail 멤버변수를 갖는 DoublyLinkedList(이중 연결 리스트)로 구현되어 있다.

## SinglyLinkedList.java
- 처음, 끝 node를 가리키는 포인터 역할의 멤버변수 head, tail이 있다.
- dummy node가 없는 구조로 구현했다.

## DoublyLinkedList.java
- 처음 node를 가리키는 포인터 역할의 멤버변수 head가 있다.
- dummy node가 없는 구조로 구현했다.
- 길이가 1일 경우, 첫 node의 이전, 다음 node는 자신을 가리킨다.